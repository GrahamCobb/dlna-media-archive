#!/usr/bin/perl
# Copyright (C) 2005 by Satoshi Konno
# Copyright (C) 2014 Graham R. Cobb
# Released under GPL V2 -- see LICENSE
# Much of this code is taken from the documentation for Net::UPnP::AV::MediaServer -- see http://search.cpan.org/~skonno/Net-UPnP-1.4/lib/Net/UPnP/AV/MediaServer.pm

use strict;
use warnings;

use Getopt::Long 2.33 qw(:config gnu_getopt auto_help auto_version);
use Pod::Usage;
use Net::UPnP::ControlPoint;
use Net::UPnP::AV::MediaServer;
use File::Spec;
use File::Path qw(make_path);
use HTTP::Tiny;
use Text::Glob qw( match_glob glob_to_regex );

our $VERSION = 0.2;

my $verbosity = 2;
my $man = 0;
my $topDir = "";

#
# Logging
#
sub msgError
{
    print @_,"\n";
}
sub msgInfo
{
    print @_,"\n" if $verbosity >= 1;
}
sub msgProgress
{
    print @_,"\n" if $verbosity >= 2;
}
sub msgDebug
{
    print @_,"\n" if $verbosity >= 3;
}

#
# Option processing
#
#Getopt::Long::Configure ("bundling");
GetOptions(
	   "destination|d=s" => \$topDir,
	   "verbose|v:+" => \$verbosity,
	   "man" => \$man,
	   ) or pod2usage(2);
msgDebug "man = $man";
if ($man) {
    pod2usage(-verbose => 2);
    exit;
}

my ($serverName) = @ARGV;

msgDebug "verbosity = $verbosity";
msgDebug "serverName = $serverName" if $serverName;
msgDebug "topDir = $topDir";

=head1 NAME

dlna-media-archive - Archive material from DLNA media servers

=head1 SYNOPSIS

dlna-media-archive [options] [<server-name>]

dlna-media-archive -?|--help|--man|--version

 Commands:

  -?, --help			brief help message
  --man 			full documentation
  --version			script version

 Options:

  -d, --destination=<path>	Destination directory for creating archive tree
  -v, --verbose[=N]		Increment or set verbosity level (0 - quiet, 1 - info, 2 - progress, 3 - debug)

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=back

=head1 DESCRIPTION

B<dlna-media-archive> downloads all the content from all the DLNA media servers
it can see.

B<server-name> specifies the name of the server (as advertised by the server).
File glob style wildcards can be included.

=head1 EXAMPLES

=over 8

=item B<dlna-media-archive "HDR-2000T*">

Downloads all content from all Humax HDR-2000T servers.

=back

=cut



my $obj = Net::UPnP::ControlPoint->new();

my @dev_list = $obj->search(st =>'upnp:rootdevice', mx => 3);

my $servers = 0;
foreach my $dev (@dev_list) {
    my $device_type = $dev->getdevicetype();
    if  ($device_type ne 'urn:schemas-upnp-org:device:MediaServer:1') {
	next;
    }
    unless ($dev->getservicebyname('urn:schemas-upnp-org:service:ContentDirectory:1')) {
	next;
    }
    if ($serverName) {
	if (! match_glob($serverName, $dev->getfriendlyname())) {
	    next;
	}
    } else {
	msgInfo "Archiving server ", $dev->getfriendlyname(), "...";
    }
    
    $servers++;

    my $mediaServer = Net::UPnP::AV::MediaServer->new();
    $mediaServer->setdevice($dev);

    walk_tree($mediaServer, 0, File::Spec->catdir($topDir || File::Spec->curdir(), $dev->getfriendlyname()));
}

if (!$servers) {
    if ($serverName) {
	msgError "No servers found matching $serverName";
    } else {
	msgError "No servers found";
    }
    exit 1;
}

sub walk_tree {
    my ($mediaServer, $id, $dir) = @_;

    my @content_list = $mediaServer->getcontentlist(ObjectID => $id );

    foreach my $content (@content_list) {
	if ($content->isitem()) {
	    archive_content($mediaServer, $dir, $content);
	} else {
	    walk_tree($mediaServer, $content->getid(), File::Spec->catdir($dir, $content->gettitle()));
	}	    
    }
}    

sub archive_content {
    my ($mediaServer, $dir, $content) = @_;

    make_path($dir) unless -d $dir;

    my $url = $content->geturl();
    my $file = File::Spec->catfile($dir, $content->gettitle());
    msgDebug "($url => $file)";

    # HTTP::Tiny::mirror handles safe mirroring (redownload if incomplete or if file has changed).
    # Unfortunately, the Media Server does not necessarily handle the If-Modified-Since header
    # so we just do not download if the file already exists. This is safe as HTTP::Tiny::mirror
    # will not have renamed the download to the specified name unless the download was successful.
    if (! -e $file) {
	msgProgress "$url => $file";
	my $http = HTTP::Tiny->new();
	my $resp = $http->mirror($url, $file);
	unless ($resp->{success}) {die "Download of $url failed: ", $resp->{status}, $resp->{reason};}
    }
}
